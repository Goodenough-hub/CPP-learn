[TOC]
# 继承的基本概念和语法
## 类的继承与派生概述
- 继承与派生是同一过程从不同的角度看
  - 保持已有类的特性而构造新类的过程称为继承
  - 在已有类的基础上新增自己的特性而产生新类的过程称为派生。
- 被继承的已有类称为基类（或父类）
- 派生出的新类称为派生类（或子类）
- 直接参与派生出某类的基类称为直接基类
- 基类的基类甚至更高层的基类称为间接基类
## 继承与派生的目的
- 继承的目的：实现设计与代码的重用
- 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。
## 派生类的定义
- 单继承时
  ```c++
  class 派生类名：继承方式 基类名
  {
    成员声明；
  }
  ```
  - 例如：
    ```c++
    class Derived:public Base
    {
        public:
            Derived();
            ~Derived();
    };
    ```
- 多继承时
    ```c++
    class 派生类名：继承方式1 基类名1，继承方式2 基类名2， ...
    {
        成员声明；
    }
    ```
  - 注意：每一个“继承方式”，只用于限制对紧随其后之基类的继承。例如：
    ```c++
    class Derived: public Base1, private Base Base2
    {
        public:
            Derived();
            ~Derived();
    };
    ```
## 派生类的构成
- 吸收基类成员
  - 吸收基类成员之后，派生类实际上就包含了它的全部基类中除构造和析构函数之外的所有成员。
- 改造基类成员
  - 如果派生类声明了一个和某基类成员同名的新成员，派生的新成员就隐藏或覆盖了外层同名成员
- 添加新的成员
  - 派生类增加了新成员使派生类在功能上有所发展。
## 不同继承方式及类成员的访问控制
- 不同继承方式的影响主要体现在：
  - 派生类成员对基类成员的访问权限
  - 通过派生类对象对基类成员的访问权限
- 三种继承方式
  - 公有继承
  - 私有继承
  - 保护继承
### 公有继承（public）
- 基类的`public`和`protected`成员的访问属性在派生类中保持不变，但基类的`private`成员不可直接访问。
- 派生类中的成员函数可以直接访问基类中的`public`和`protected`成员,但不能直接访问基类的`private`成员。
- 通过派生类的对象访问从基类继承的成员，只能访问`public`成员。
### protected成员的特点与作用
- 对建立其所在类对象的模块来说，它与`private`成员的性质相同。
- 对于其派生类来说，它与`public`成员的性质相同。
- 既实现了数据隐藏，又方便继承，实现代码重用。

例：`procted 成员举例`
```c++
class A{
    protected:
        int x;
};

int main(){
    A a;
    a.x = 5; // 错误
}
```
```c++
class A{
    protected:
        int x;
};
class B: public A{
    public:
        void function();
};
void B::function(){
    x = 5; // 正确
}
```
### 私有继承（private）
- 基类的`public`和`protected`成员都以`private`身份出现在派生类中，但基类的`private`成员不可直接访问。
- 派生类中的成员函数可以直接访问基类中的`public`和`protected`成员，但不能直接访问基类的`private`成员。
- 通过派生类中的对象不能直接访问从基类继承的任何成员。
### 保护继承（protected）
- 基类的`public`和`protected`成员都以`protected`身份出现在派生类中，但基类的`private`成员不可直接访问。
- 派生类中的成员函数可以直接访问基类中的`public`和`protected`成员，但不能直接访问基类的`private`成员。
- 通过派生类的对象不能直接访问从基类继承的任何成员
## 向上转型
- 一个公有派生类的对象在使用上可以被当做基类的对象，反之则不可。具体表现在：
  - 派生类的对象可以隐含转换为基类对象。
  - 派生类的对象可以初始化基类的引用。
  - 派生类的指针可以隐含转换为基类的指针。
- 通过基类对象名、指针只能使用从基类继承的成员
例：7_3类型转换规则举例
```c++
#include<iostream>
using namespace std;
class Base1{ // 基类Base1定义 
	public:
		void display() const { cout << "Base1::display()" << endl; }
};

class Base2:public Base1{ // 公有派生类Base2定义 
	public: 
		void display() const { cout << "Base2::display()" << endl; }
}; 

class Derived:public Base2{ // 公有派生类Derived定义 
	public:
		void display() const { cout << "Derived::display()" << endl; }
}; 

void fun(Base1 *ptr){ // 参数为指向基类对象的指针 
	ptr->display(); // “对象指针->成员名” 
}

int main(){
	Base1 base1; // 声明Base1类对象 
	Base2 base2; // 声明Base2类对象 
	Derived derived; // 声明Derived类对象 
	
	fun(&base1); // 用Base1对象的指针调用fun函数 
	fun(&base2); // 用Base2对象的指针调用fun函数 
	fun(&derived); // 用Derived对象的指针调用fun函数 
	
	return 0;
} 
```
> 绝对不要重新定义继承而来的非虚函数

# 派生类对象的构造与析构
## 继承时的构造函数
- 默认情况下基类的构造函数不被继承，派生类需要定义自己的构造函数。
- 定义构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员初始化，是自动调用基类构造函数来完成的。
- 派生类的构造函数需要给基类的构造函数传递参数。
- C++11规定可以使用`using`语句继承基类构造函数，使之成为派生类的构造函数，但是只能初始化从基类继承的成员。
  - 语法形式
    `using Base::Base;`
## 单一继承时构造函数的定义
派生类名::派生类名（基类所需的形参，本类成员所需的形参）:
基类名（参数表），本类成员初始化列表
{
    // 其他初始化；
};
- 单一继承时的构造函数举例
  ```c++
  #include<iostream>
  using namespace std;
  class B{
    public:
        B();
        B(int i);
        ~B();
        void print() const;
    private:
        nt b;
  };
  B::B(){
    b = 0;;
    cout << "B's defalut constructor called." << endl;
  }
  B::(int i){
    b = i;
    cout << "B's constructor called." << endl;
  }
  B::~B{
    cout << "B's destructor called." << endl;
  }
  void B::print() const{
    cout << b << endl;
  }

  class C:public B{
    public:
        C();
        C(int i, int j);
        ~C();
        void print() const;
    private:
        int c;
  };
  C::C(){
    c = 0;
    cout << "C's default constructor called." << endl;
  }
  C::C(int i, int j): B(i), c(j){
    cout << "C's constructor called." << endl;
  }
  C::~C(){
    cout << "C's destructor called." << endl;
  }
  void C::print() const{
    B::print();
    cout << c << endl;
  }

  int main(){
    C obj(5, 6);
    obj.print();
    return 0;
  }
  ```
## 多继承时的构造的定义
派生类名::派生类名（参数表）：基类名1（基类1初始化参数表），基类名2（基类2初始化参数表），...，基类名n（基类n初始胡参数表），本类成员初始化列表
{
    // 其他初始化；
};

## 派生类与基类的构造函数
- 当基类中声明有默认构造函数或未声明构造函数时，派生类构造函数可以不向基类构造函数传递参数，也可以不声明构造函数。构造派生类的对象时，基类的默认构造函数将被调用。
- 当需要执行基类中带形参的构造函数来初始化基类数据时，派生类构造函数应在初始化列表中为基类构造函数提供参数。
## 多继承且有对象成员时的构造函数
既有继承又有组合的情况：
派生类名::派生类名（形参表):基本名1（参数），基类名2（参数），...，基类名n（参数），对象成员初始化列表，基本类型成员初始化列表
{
    // 其他初始化；
};
## 构造函数的执行顺序
1. 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。
2. 对初始化列表中的对象成员和基本类型成员进行初始化，初始化顺序按照它们在类中声明的顺序。对象成员初始化是自动调用对象所属类的构造函数完成的。
3. 执行派生类的构造函数体中的内容。
## 复制构造函数
- 若建立派生类对象时没有编写复制构造函数，编译器会生成一个隐含的复制构造函数，该函数先调用基类的复制构造函数，再为派生类新增的成员对象执行复制。
- 若编写派生类的复制构造函数，一般都要为基类的复制构造函数传递参数。
- 派生类的复制构造函数只能接受一个参数，此参数不仅用来初始化派生类定义的成员，也将被传递给基类的复制构造函数。
- 基类的复制构造函数形参类型是基类对象的引用，实参可以是派生类对象的引用
  - 例如：
  `C::C(const C &c1): B(c1){...}`
## 析构函数
- 析构函数不被继承，派生类如果需要，要自行声明析构函数
- 声明方法与一般（无继承关系时）类的析构函数相同。
- 不需要显示地调用基类的析构函数，系统会自动隐式调用。
- 析构函数的调用次序与析构函数相反。

# 虚继承
## 基类成员访问
### 作用域限定
- 当派生类与基类中有相同成员时：
  - 若未特别限定时，则通过派生类对象使用的是派生类中的同名成员。
  - 如要通过派生类对象访问基类中被隐藏1的同名成员，应使用基类名和作用域操作符(::)来限定。
### 二义性问题
- 如果从不同基类继承了同名成员，但是在派生类中没有定义同名成员，`派生类对象名或引用名.成员名`，`派生类指针->成员名`访问成员存在二义性问题
- 解决方式：用类名限定
## 虚基类的语法和用途
- 需要解决的问题
  - 当派生类从多个基类派生，而这些基类又共同基类，则在访问此共同基类中的成员时，将产生冗余，并有可能因冗余带来不一致性
- 虚基类声明
  - 以`virtual`说明基类继承方式
  例：`class B1:virtual public B`
- 作用
  - 主要用来解决多继承时可能1发生的对同一基类继承多次而产生的二义性问题
  - 为最远的派生类提供唯一的基类成员，而不重复产生多次复制
- 注意：
  - 在第一级继承时就要将共同基类设计为虚基类。
## 虚基类及其派生类构造函数
- 建立对象时所指定的类称为最远派生类。
- 虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。
- 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中为虚基类的构造函数列出参数。如果未列出，则表示调用该虚基类的默认构造函数。
- 在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，其他类对虚基类构造函数的调用被忽略。

# 小结
- 主要内容
  - 类的继承、类成员的访问控制、单继承与多继承、派生类的构造和析构函数、类成员的标识与访问、虚继承
- 达到的目标
  - 掌握继承的思想和语法
  - 掌握继承时类成员的访问控制
  - 掌握基类与派生类之间的类型转换规则
  - 学会定义派生类的构造和析构函数，理解构造函数与析构函数的调用时机
  - 了解派生类成员的标识与访问，掌握虚基类